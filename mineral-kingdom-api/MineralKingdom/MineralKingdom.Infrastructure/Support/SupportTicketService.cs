using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.EntityFrameworkCore;
using MineralKingdom.Contracts.Support;
using MineralKingdom.Infrastructure.Notifications;
using MineralKingdom.Infrastructure.Persistence;
using MineralKingdom.Infrastructure.Persistence.Entities;

namespace MineralKingdom.Infrastructure.Support;

public sealed class SupportTicketService
{
  private static readonly TimeSpan GuestTokenLifetime = TimeSpan.FromDays(30);

  private readonly MineralKingdomDbContext _db;
  private readonly EmailOutboxService _emailOutbox;

  public SupportTicketService(MineralKingdomDbContext db, EmailOutboxService emailOutbox)
  {
    _db = db;
    _emailOutbox = emailOutbox;
  }

  public static string GenerateRawToken(int bytes = 32)
  {
    var buffer = RandomNumberGenerator.GetBytes(bytes);
    return Convert.ToBase64String(buffer)
      .TrimEnd('=')
      .Replace('+', '-')
      .Replace('/', '_');
  }

  public static string ComputeTokenHash(string rawToken)
  {
    using var sha = SHA256.Create();
    var bytes = Encoding.UTF8.GetBytes(rawToken);
    var hash = sha.ComputeHash(bytes);
    return Convert.ToHexString(hash).ToLowerInvariant();
  }

  public async Task<(bool Ok, string? Error, CreateSupportTicketResponse? Response)> CreateTicketAsync(
    Guid? memberUserId,
    CreateSupportTicketRequest req,
    string apiBaseUrl,
    DateTimeOffset now,
    CancellationToken ct)
  {
    if (req is null) return (false, "INVALID_REQUEST", null);

    var subject = (req.Subject ?? "").Trim();
    var category = (req.Category ?? "").Trim().ToUpperInvariant();
    var message = (req.Message ?? "").Trim();

    if (string.IsNullOrWhiteSpace(subject) || subject.Length > 200) return (false, "INVALID_SUBJECT", null);
    if (string.IsNullOrWhiteSpace(message) || message.Length > 4000) return (false, "INVALID_MESSAGE", null);
    if (!SupportTicketCategories.Allowed.Contains(category)) return (false, "INVALID_CATEGORY", null);

    // enforce "at most one linked id"
    var linkedCount =
      (req.LinkedOrderId is null ? 0 : 1) +
      (req.LinkedAuctionId is null ? 0 : 1) +
      (req.LinkedShippingInvoiceId is null ? 0 : 1) +
      (req.LinkedListingId is null ? 0 : 1);

    if (linkedCount > 1) return (false, "TOO_MANY_LINKED_REFS", null);

    string? guestEmail = null;
    if (memberUserId is null)
    {
      guestEmail = (req.Email ?? "").Trim().ToLowerInvariant();
      if (string.IsNullOrWhiteSpace(guestEmail) || guestEmail.Length > 320) return (false, "EMAIL_REQUIRED", null);
    }

    // TicketNumber is generated by DB default in migration; but to be safe in tests/dev,
    // we’ll set it here if empty after SaveChanges (rare).
    var ticket = new SupportTicket
    {
      Id = Guid.NewGuid(),
      TicketNumber = "PENDING",
      CreatedByUserId = memberUserId,
      GuestEmail = guestEmail,
      Subject = subject,
      Category = category,
      Priority = SupportTicketPriorities.Normal,
      Status = SupportTicketStatuses.Open,
      AssignedToUserId = null,
      LinkedOrderId = req.LinkedOrderId,
      LinkedAuctionId = req.LinkedAuctionId,
      LinkedShippingInvoiceId = req.LinkedShippingInvoiceId,
      LinkedListingId = req.LinkedListingId,
      CreatedAt = now,
      UpdatedAt = now,
      ClosedAt = null
    };

    var msg = new SupportTicketMessage
    {
      Id = Guid.NewGuid(),
      TicketId = ticket.Id,
      AuthorType = "CUSTOMER",
      AuthorUserId = memberUserId,
      BodyText = message,
      IsInternalNote = false,
      CreatedAt = now
    };

    _db.SupportTickets.Add(ticket);
    _db.SupportTicketMessages.Add(msg);

    // Guest token issuance
    string? rawToken = null;
    if (memberUserId is null)
    {
      rawToken = GenerateRawToken();
      var tokenRow = new SupportTicketAccessToken
      {
        Id = Guid.NewGuid(),
        TicketId = ticket.Id,
        TokenHash = ComputeTokenHash(rawToken),
        CreatedAt = now,
        ExpiresAt = now.Add(GuestTokenLifetime),
        UsedAt = null
      };
      _db.SupportTicketAccessTokens.Add(tokenRow);
    }

    await _db.SaveChangesAsync(ct);

    // If migration doesn’t provide default ticket number yet, do a fallback.
    if (ticket.TicketNumber == "PENDING")
    {
      ticket.TicketNumber = $"ST-{ticket.Id.ToString()[..8].ToUpperInvariant()}";
      ticket.UpdatedAt = now;
      await _db.SaveChangesAsync(ct);
    }

    // Determine notification email target
    string? toEmail = guestEmail;
    if (toEmail is null && memberUserId is not null)
    {
      toEmail = await _db.Users
        .AsNoTracking()
        .Where(u => u.Id == memberUserId)
        .Select(u => u.Email)
        .SingleOrDefaultAsync(ct);
    }

    if (!string.IsNullOrWhiteSpace(toEmail))
    {
      var viewLink = BuildTicketLink(apiBaseUrl, ticket.Id, rawToken);

      var payload = JsonSerializer.Serialize(new
      {
        ticketId = ticket.Id,
        ticketNumber = ticket.TicketNumber,
        subject = ticket.Subject,
        category = ticket.Category,
        viewLink
      });

      // dedupe per ticket creation
      await _emailOutbox.EnqueueAsync(
        toEmail: toEmail,
        templateKey: "SupportRequestReceived",
        payloadJson: payload,
        dedupeKey: $"support:received:{ticket.Id}",
        now: now,
        ct: ct);
    }

    return (true, null, new CreateSupportTicketResponse(ticket.Id, ticket.TicketNumber, rawToken));
  }

  public async Task<(bool Ok, string? Error, SupportTicketDto? Ticket)> GetTicketForMemberAsync(
    Guid ticketId,
    Guid memberUserId,
    bool isAdmin,
    CancellationToken ct)
  {
    var t = await LoadTicketAsync(ticketId, includeInternalNotes: isAdmin, ct);
    if (t is null) return (false, "NOT_FOUND", null);

    if (!isAdmin && t.CreatedByUserId != memberUserId) return (false, "FORBIDDEN", null);

    return (true, null, t);
  }

  public async Task<(bool Ok, string? Error, SupportTicketDto? Ticket)> GetTicketForGuestAsync(
    Guid ticketId,
    string rawToken,
    CancellationToken ct)
  {
    if (string.IsNullOrWhiteSpace(rawToken)) return (false, "TOKEN_REQUIRED", null);

    var hash = ComputeTokenHash(rawToken.Trim());
    var now = DateTimeOffset.UtcNow;

    var valid = await _db.SupportTicketAccessTokens
      .AsNoTracking()
      .AnyAsync(x => x.TicketId == ticketId && x.TokenHash == hash && x.ExpiresAt > now, ct);

    if (!valid) return (false, "INVALID_TOKEN", null);

    var t = await LoadTicketAsync(ticketId, includeInternalNotes: false, ct);
    if (t is null) return (false, "NOT_FOUND", null);

    return (true, null, t);
  }

  public async Task<(bool Ok, string? Error)> AddCustomerMessageAsMemberAsync(
    Guid ticketId,
    Guid memberUserId,
    string message,
    DateTimeOffset now,
    CancellationToken ct)
  {
    var ticket = await _db.SupportTickets.SingleOrDefaultAsync(x => x.Id == ticketId, ct);
    if (ticket is null) return (false, "NOT_FOUND");

    if (ticket.CreatedByUserId != memberUserId) return (false, "FORBIDDEN");

    return await AddCustomerMessageCoreAsync(ticket, memberUserId, message, now, ct);
  }

  public async Task<(bool Ok, string? Error)> AddCustomerMessageAsGuestAsync(
    Guid ticketId,
    string rawToken,
    string message,
    DateTimeOffset now,
    CancellationToken ct)
  {
    var hash = ComputeTokenHash((rawToken ?? "").Trim());
    var valid = await _db.SupportTicketAccessTokens
      .AnyAsync(x => x.TicketId == ticketId && x.TokenHash == hash && x.ExpiresAt > now, ct);

    if (!valid) return (false, "INVALID_TOKEN");

    var ticket = await _db.SupportTickets.SingleOrDefaultAsync(x => x.Id == ticketId, ct);
    if (ticket is null) return (false, "NOT_FOUND");

    return await AddCustomerMessageCoreAsync(ticket, authorUserId: null, message, now, ct);
  }

  private async Task<(bool Ok, string? Error)> AddCustomerMessageCoreAsync(
    SupportTicket ticket,
    Guid? authorUserId,
    string message,
    DateTimeOffset now,
    CancellationToken ct)
  {
    var body = (message ?? "").Trim();
    if (string.IsNullOrWhiteSpace(body) || body.Length > 4000) return (false, "INVALID_MESSAGE");

    _db.SupportTicketMessages.Add(new SupportTicketMessage
    {
      Id = Guid.NewGuid(),
      TicketId = ticket.Id,
      AuthorType = "CUSTOMER",
      AuthorUserId = authorUserId,
      BodyText = body,
      IsInternalNote = false,
      CreatedAt = now
    });

    ticket.Status = SupportTicketStatuses.WaitingOnSupport;
    ticket.UpdatedAt = now;

    await _db.SaveChangesAsync(ct);
    return (true, null);
  }

  public async Task<IReadOnlyList<AdminSupportTicketListItem>> AdminListAsync(
    string? status,
    string? priority,
    Guid? assignedToUserId,
    string? q,
    int page,
    int pageSize,
    CancellationToken ct)
  {
    if (page < 1) page = 1;
    if (pageSize < 1) pageSize = 20;
    if (pageSize > 100) pageSize = 100;

    var query = _db.SupportTickets.AsNoTracking();

    if (!string.IsNullOrWhiteSpace(status))
      query = query.Where(t => t.Status == status.Trim().ToUpperInvariant());

    if (!string.IsNullOrWhiteSpace(priority))
      query = query.Where(t => t.Priority == priority.Trim().ToUpperInvariant());

    if (assignedToUserId is not null)
      query = query.Where(t => t.AssignedToUserId == assignedToUserId);

    if (!string.IsNullOrWhiteSpace(q))
    {
      var s = q.Trim().ToLowerInvariant();
      query = query.Where(t =>
        t.TicketNumber.ToLower().Contains(s) ||
        t.Subject.ToLower().Contains(s) ||
        (t.GuestEmail != null && t.GuestEmail.ToLower().Contains(s)));
    }

    var rows = await query
      .OrderByDescending(t => t.UpdatedAt)
      .Skip((page - 1) * pageSize)
      .Take(pageSize)
      .Select(t => new AdminSupportTicketListItem(
        t.Id,
        t.TicketNumber,
        t.Subject,
        t.Category,
        t.Priority,
        t.Status,
        t.AssignedToUserId,
        t.CreatedByUserId,
        t.GuestEmail,
        t.UpdatedAt))
      .ToListAsync(ct);

    return rows;
  }

  public async Task<(bool Ok, string? Error)> AdminUpdateAsync(
    Guid ticketId,
    AdminUpdateSupportTicketRequest req,
    DateTimeOffset now,
    CancellationToken ct)
  {
    var t = await _db.SupportTickets.SingleOrDefaultAsync(x => x.Id == ticketId, ct);
    if (t is null) return (false, "NOT_FOUND");

    if (req.Status is not null)
    {
      var s = req.Status.Trim().ToUpperInvariant();
      if (!SupportTicketStatuses.Allowed.Contains(s)) return (false, "INVALID_STATUS");
      t.Status = s;
      if (s == SupportTicketStatuses.Closed) t.ClosedAt = now;
      if (s != SupportTicketStatuses.Closed) t.ClosedAt = null;
    }

    if (req.Priority is not null)
    {
      var p = req.Priority.Trim().ToUpperInvariant();
      if (!SupportTicketPriorities.Allowed.Contains(p)) return (false, "INVALID_PRIORITY");
      t.Priority = p;
    }

    // note: AssignedToUserId can be set/unset
    t.AssignedToUserId = req.AssignedToUserId;

    t.UpdatedAt = now;
    await _db.SaveChangesAsync(ct);

    return (true, null);
  }

  public async Task<(bool Ok, string? Error)> AdminAddMessageAsync(
    Guid ticketId,
    Guid adminUserId,
    AdminCreateSupportMessageRequest req,
    string apiBaseUrl,
    DateTimeOffset now,
    CancellationToken ct)
  {
    var ticket = await _db.SupportTickets.SingleOrDefaultAsync(x => x.Id == ticketId, ct);
    if (ticket is null) return (false, "NOT_FOUND");

    var body = (req.Message ?? "").Trim();
    if (string.IsNullOrWhiteSpace(body) || body.Length > 4000) return (false, "INVALID_MESSAGE");

    _db.SupportTicketMessages.Add(new SupportTicketMessage
    {
      Id = Guid.NewGuid(),
      TicketId = ticket.Id,
      AuthorType = "SUPPORT",
      AuthorUserId = adminUserId,
      BodyText = body,
      IsInternalNote = req.IsInternalNote,
      CreatedAt = now
    });

    if (!req.IsInternalNote)
    {
      ticket.Status = SupportTicketStatuses.WaitingOnCustomer;
      ticket.UpdatedAt = now;
    }

    await _db.SaveChangesAsync(ct);

    if (!req.IsInternalNote)
    {
      var toEmail = ticket.GuestEmail;

      if (toEmail is null && ticket.CreatedByUserId is not null)
      {
        toEmail = await _db.Users
          .AsNoTracking()
          .Where(u => u.Id == ticket.CreatedByUserId)
          .Select(u => u.Email)
          .SingleOrDefaultAsync(ct);
      }

      if (!string.IsNullOrWhiteSpace(toEmail))
      {
        // For guest tickets, ensure there is a valid token; create one if not.
        string? rawToken = null;
        if (ticket.CreatedByUserId is null)
        {
          rawToken = await EnsureGuestTokenAsync(ticket.Id, now, ct);
        }

        var viewLink = BuildTicketLink(apiBaseUrl, ticket.Id, rawToken);

        var payload = JsonSerializer.Serialize(new
        {
          ticketId = ticket.Id,
          ticketNumber = ticket.TicketNumber,
          replyBody = body,
          viewLink
        });

        await _emailOutbox.EnqueueAsync(
          toEmail: toEmail,
          templateKey: "SupportReplySent",
          payloadJson: payload,
          dedupeKey: $"support:reply:{ticket.Id}:{now:yyyyMMddHHmmssfff}",
          now: now,
          ct: ct);
      }
    }

    return (true, null);
  }

  private async Task<string> EnsureGuestTokenAsync(Guid ticketId, DateTimeOffset now, CancellationToken ct)
  {
    // Tokens are stored hashed; we cannot reconstruct a raw token to include in emails.
    // For email links, always mint a fresh token.
    var raw = GenerateRawToken();
    var row = new SupportTicketAccessToken
    {
      Id = Guid.NewGuid(),
      TicketId = ticketId,
      TokenHash = ComputeTokenHash(raw),
      CreatedAt = now,
      ExpiresAt = now.Add(GuestTokenLifetime),
      UsedAt = null
    };

    _db.SupportTicketAccessTokens.Add(row);
    await _db.SaveChangesAsync(ct);
    return raw;
  }

  private static string BuildTicketLink(string apiBaseUrl, Guid ticketId, string? rawToken)
  {
    // No frontend yet: link to API endpoint (or placeholder route).
    var baseUrl = apiBaseUrl.TrimEnd('/');
    if (!string.IsNullOrWhiteSpace(rawToken))
      return $"{baseUrl}/api/support/tickets/{ticketId}?token={rawToken}";
    return $"{baseUrl}/api/support/tickets/{ticketId}";
  }

  private async Task<SupportTicketDto?> LoadTicketAsync(Guid ticketId, bool includeInternalNotes, CancellationToken ct)
  {
    var ticket = await _db.SupportTickets
      .AsNoTracking()
      .SingleOrDefaultAsync(t => t.Id == ticketId, ct);

    if (ticket is null) return null;

    var msgsQuery = _db.SupportTicketMessages.AsNoTracking()
  .Where(m => m.TicketId == ticketId);

    if (!includeInternalNotes)
      msgsQuery = msgsQuery.Where(m => !m.IsInternalNote);

    var msgs = await msgsQuery
      .OrderBy(m => m.CreatedAt)
      .Select(m => new SupportTicketMessageDto(
        m.Id,
        m.AuthorType,
        m.AuthorUserId,
        m.BodyText,
        m.IsInternalNote,
        m.CreatedAt))
      .ToListAsync(ct);

    return new SupportTicketDto(
      ticket.Id,
      ticket.TicketNumber,
      ticket.CreatedByUserId,
      ticket.GuestEmail,
      ticket.Subject,
      ticket.Category,
      ticket.Priority,
      ticket.Status,
      ticket.AssignedToUserId,
      ticket.LinkedOrderId,
      ticket.LinkedAuctionId,
      ticket.LinkedShippingInvoiceId,
      ticket.LinkedListingId,
      ticket.CreatedAt,
      ticket.UpdatedAt,
      ticket.ClosedAt,
      msgs
    );
  }
}